#from collections import deque
import numpy as np  # math libraries
#import argparse  # to find and pass files
import imutils  # resizing
import cv2  # opencv itself
from PIL import ImageGrab  # for screen capture
#from matplotlib import pyplot as plt
#adding one comment
def nothing(x):
    pass

eye_cascade = cv2.CascadeClassifier('haarcascade_eye.xml')

cap = cv2.VideoCapture(0)
frame_height = 720
frame_width = 1280
cap.set(3, frame_width)
cap.set(4, frame_height)
curr_x = 0
curr_y = 0
prev_location_x = 0
prev_location_y = 0
prev_h = 0
prev_w = 0
h, s, v = 100, 100, 100
gauss = 5
cv2.namedWindow('Control Panel')  # makes a control panel
cv2.createTrackbar('hue', 'Control Panel', 154, 180, nothing)  # sets the hue trackbar on the control panel
cv2.createTrackbar('sat', 'Control Panel', 128, 255, nothing)  # sets the sat trackbar on the control panel
cv2.createTrackbar('val', 'Control Panel', 32, 255, nothing)  # sets the val trackbar on the control panel
cv2.createTrackbar('range', 'Control Panel', 100, 127, nothing)
cv2.createTrackbar('srange', 'Control Panel', 127, 127, nothing)
while(True):

    ret, frame = cap.read()

    h = cv2.getTrackbarPos('hue', 'Control Panel')
    s = cv2.getTrackbarPos('sat', 'Control Panel')
    v = cv2.getTrackbarPos('val', 'Control Panel')
    r = cv2.getTrackbarPos('range', 'Control Panel')  # determines how big a slice you want from the hsv py
    sr = cv2.getTrackbarPos('srange', 'Control Panel')

    lowerthreshold = np.array([h-10, s-sr, v-r])
    higherthreshold = np.array([h+10, s+sr, v+r])


    #adjust_height = frame_height/2
    #adjust_width = frame_width/2

    eyes = eye_cascade.detectMultiScale(frame, scaleFactor=1.4, minNeighbors=6, minSize=(45, 45), maxSize=(100, 100))
    detection = 0
    if len(eyes):
        for(x,y,w,h) in eyes:
            cv2.rectangle(frame, (x,y), (x+w, y+h), (255,0,0), 2)
            thresh = frame[ y:y+h,x:x+w]
            prev_location_x = x
            prev_location_y = y
            prev_w = w
            prev_h = h
            hsv = cv2.cvtColor(thresh, cv2.COLOR_BGR2HSV)
            mask = cv2.inRange(hsv, lowerthreshold, higherthreshold)
            cnts = cv2.findContours(mask.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[-2]
            if len(cnts) > 0:
                # c is the biggest contour array
                c = max(cnts, key=cv2.contourArea)

                # calculate the radius and center of circle
                ((curr_x, curr_y), radius) = cv2.minEnclosingCircle(c)
                cv2.circle(thresh, (int(curr_x), int(curr_y)), int(radius), (255, 255, 0), 2, 2)
                if(curr_x > ((w/2.2))):
                    print("right")

                elif(curr_x < ((w/2))):
                    print("left")
                else:
                    print("center")
                print(curr_x)
        cv2.imshow("roi", thresh)
        cv2.imshow("mask", mask)
    else:
        cv2.rectangle(frame, (prev_location_x, prev_location_y), (prev_location_x + prev_w, prev_location_y + prev_h), (255, 0, 0), 2)

    cv2.imshow("feed", frame)

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cv2.destroyAllWindows()
